SUBROUTINE sub_ondeincidente

  Use m_mat
  Use m_gen
!  Use m_cla
  Use m_condbord
  Use m_mesh

  implicit none

  INTEGER :: I,INeigh,Node(3),J,K,L,JJ,Nbnoinc,nnt
  INTEGER,allocatable :: PhiEdge(:,:)
  REAL*8,allocatable::PhiI(:),kx(:)
  REAL*8 :: V(3,2),Testinc,pi,tmp,t
  REAL*8,allocatable :: Phi(:,:),valincidente(:,:)
  REAL*8 :: res,theta1,theta2
  allocate(Phi(1+Order,NGL1D))
  allocate(PhiEdge(3,1+Order))


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!      calcul de pi
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 pi=4.*atan(1.)


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!! nombre d'itérations en temps
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 nnt=21000

  
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!  Points et poids de quadrature 1D
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! call sub_defGL1D


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!
!!  Calcul des phi et des correspondances
!!  en fonction de l'ordre des polynômes
!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  SELECT CASE(Order)
  CASE(1)
     CALL Phi1DOrder1(PtGL1D,NGL1D,Phi) 
     !Functions on Edge 23
     PhiEdge(1,1)=2
     PhiEdge(1,2)=3
     !Functions on Edge 31
     PhiEdge(2,1)=3
     PhiEdge(2,2)=1
     !Functions on Edge 12
     PhiEdge(3,1)=1
     PhiEdge(3,2)=2

  CASE(2)
     CALL Phi1DOrder2(PtGL1D,NGL1D,Phi)
     !Functions on Edge 23
     PhiEdge(1,1)=2
     PhiEdge(1,2)=5
     PhiEdge(1,3)=3
     !Functions on Edge 31
     PhiEdge(2,1)=3
     PhiEdge(2,2)=6
     PhiEdge(2,3)=1
     !Functions on Edge 12
     PhiEdge(3,1)=1
     PhiEdge(3,2)=4
     PhiEdge(3,3)=2

  CASE(3)
     CALL Phi1DOrder3(PtGL1D,NGL1D,Phi)
     !Functions on Edge 23
     PhiEdge(1,1)=2
     PhiEdge(1,2)=6
     PhiEdge(1,3)=7
     PhiEdge(1,4)=3
     !Functions on Edge 31
     PhiEdge(2,1)=3
     PhiEdge(2,2)=8
     PhiEdge(2,3)=9
     PhiEdge(2,4)=1
     !Functions on Edge 12
     PhiEdge(3,1)=1
     PhiEdge(3,2)=4
     PhiEdge(3,3)=5
     PhiEdge(3,4)=2
  END SELECT



!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!! calcul de k.X pour chaque points de quadrature 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!k=(k1,k2)
 allocate(kx(NGL1D))
! do i=1,NGL1D 
!	tmp=PtGL1D(i)*(2*pi)
!	kx(i)=k1*cos(tmp)+k2*sin(tmp)
! enddo

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!! calcul de valincidente
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! allocate(valincidente(nnt,NGL1D))
! valincidente=0.D0
!
! do i=1,nnt
!	t=(i-1)*dt
!	do j=1,NGL1D
!		valincidente(i,j)=sin(rayon_obstacle*kx(j)-omega_incident*t)*kx(j)
!	enddo
!enddo

!!Int(PhiIPhiJ) (1D)
!allocate(PhiI(1+Order))
!DO I=1,1+Order
!      PhiI(I)=sum(Phi(I,:)*wGL1D)
!END DO

Nbinc=0

DO I=1,Ntri
   DO J=1,3
      IF ((Neigh(I,J).gt.0).and.(Type_media(I).eq.1).and.(VELOC(Neigh(I,J)).eq.2)) THEN
	Nbinc=Nbinc+1
	exit
      END IF
   END DO
END DO
allocate(Triinc(Nbinc))
!allocate(Clatri(Ntri))
allocate(TriNoinc(NTri-Nbinc))
allocate(Binc(Nbinc,Nphi,nnt))
Binc=0.D0
!BCla2=0.D0
Nbinc=0
Nbnoinc=0

DO I=1,NTri
   Node = Tri(I,:)
   !!Computation of vectors V12,V23 and V31
   V(1,1)=Coor(Node(3),1)-Coor(Node(2),1)
   V(1,2)=Coor(Node(3),2)-Coor(Node(2),2)
   V(2,1)=Coor(Node(1),1)-Coor(Node(3),1)
   V(2,2)=Coor(Node(1),2)-Coor(Node(3),2)
   V(3,1)=Coor(Node(2),1)-Coor(Node(1),1)
   V(3,2)=Coor(Node(2),2)-Coor(Node(1),2)
   Testinc=0
   DO JJ=1,3
!!! Searching Neighbor
      INeigh=Neigh(I,JJ)
!!! If there is a Neighbor
      IF ((Neigh(I,J).gt.0).and.(VELOC(I).eq.1).and.(VELOC(Neigh(I,J)).eq.2)) THEN
	 if (JJ.eq.1) then
			if (coor(Node(2),2).gt.0) then
				theta1=acos(coor(Node(2),1)/rayon_obstacle)
			elseif (coor(Node(2),2).eq.0) then
					if (coor(Node(3),2).gt.0) then
						theta1=acos(coor(Node(2),1)/rayon_obstacle)
					else 
						theta1=2*pi-acos(coor(Node(2),1)/rayon_obstacle)
					end if
			else
					theta1=2*pi-acos(coor(Node(2),1)/rayon_obstacle)
			end if
				
			if (coor(Node(3),2).gt.0) then
				theta2=acos(coor(Node(3),1)/rayon_obstacle)
			elseif (coor(Node(3),2).eq.0) then
					if (coor(Node(2),2).gt.0) then
						theta2=acos(coor(Node(3),1)/rayon_obstacle)
					else 
						theta2=2*pi-acos(coor(Node(3),1)/rayon_obstacle)
					end if
			else
				theta2=2*pi-acos(coor(Node(3),1)/rayon_obstacle)
			end if	

	else if (JJ.eq.2) then
			if (coor(Node(3),2).gt.0) then
				theta1=acos(coor(Node(3),1)/rayon_obstacle)
			elseif (coor(Node(3),2).eq.0) then
					if (coor(Node(1),2).gt.0) then
						theta1=acos(coor(Node(3),1)/rayon_obstacle)
					else 
						theta1=2*pi-acos(coor(Node(3),1)/rayon_obstacle)
					end if
			else
					theta1=2*pi-acos(coor(Node(3),1)/rayon_obstacle)
			end if				

			if (coor(Node(1),2).gt.0) then
				theta2=acos(coor(Node(1),1)/rayon_obstacle)
			elseif (coor(Node(1),2).eq.0) then
					if (coor(Node(3),2).gt.0) then
						theta2=acos(coor(Node(1),1)/rayon_obstacle)
					else 
						theta2=2*pi-acos(coor(Node(1),1)/rayon_obstacle)
					end if
			else
					theta2=2*pi-acos(coor(Node(1),1)/rayon_obstacle)
			end if

	else
			if (coor(Node(1),2).gt.0) then
				theta1=acos(coor(Node(1),1)/rayon_obstacle)
			elseif (coor(Node(1),2).eq.0) then
					if (coor(Node(2),2).gt.0) then
						theta1=acos(coor(Node(1),1)/rayon_obstacle)
					else 
						theta1=2*pi-acos(coor(Node(1),1)/rayon_obstacle)
					end if
			else
					theta1=2*pi-acos(coor(Node(1),1)/rayon_obstacle)
			end if				

			if (coor(Node(2),2).gt.0) then
				theta2=acos(coor(Node(2),1)/rayon_obstacle)
			elseif (coor(Node(2),2).eq.0) then
					if (coor(Node(1),2).gt.0) then
						theta2=acos(coor(Node(2),1)/rayon_obstacle)
					else 
						theta2=2*pi-acos(coor(Node(2),1)/rayon_obstacle)
					end if
			else
					theta2=2*pi-acos(coor(Node(2),1)/rayon_obstacle)
			end if	
	end if

!			if (theta1.ge.theta2) then
!				tmp=theta2
!				theta2=theta1
!				theta1=tmp
!			end if

	do j=1,NGL1D 
		tmp=PtGL1D(j)*(theta2-theta1)+theta1
		kx(j)=k1*cos(tmp)+k2*sin(tmp)
	enddo

         If (Testinc==0) then
            Testinc=1
            Nbinc=Nbinc+1
            Triinc(Nbinc)=I
           ! Clatri(I)=Nbcla
         END If
         !! [u][v]
	 DO J=1,nnt
           t=(J-1)*dt 
           DO K=1,Order+1
               res=sum(Phi(K,:)*wGL1D*sin(rayon_obstacle*kx(:)-omega_incident*t)*kx(:))
               L=PhiEdge(JJ,K)
	       Binc(Nbinc,L,J)=Binc(Nbinc,L,J)+rayon_obstacle*res*(theta2-theta1)*veloc(I)
            END DO
         END DO
      END IF
   END DO
   IF (Testinc==0) then
      Nbnoinc=Nbnoinc+1
      Trinoinc(Nbnoinc)=I
   END IF
END DO 

END SUBROUTINE sub_ondeincidente
